# -*- coding: utf-8 -*-
"""simpleCNNApp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zWRh_QgCr59ddBLXGU2IDOOWYWY6DJAw
"""

import torch
import torchvision
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
from torchvision.datasets import CIFAR10
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

transform = transforms.Compose([transforms.ToTensor(),
                                transforms.RandomHorizontalFlip(),
                                transforms.RandomVerticalFlip(),
                                transforms.Normalize((0.5,),(0.5,))])

batch_size = 64
num_epochs = 15

trainset = CIFAR10(root="./content", train=True, download=True, transform=transform)
train_dataloader = DataLoader(dataset=trainset, batch_size=batch_size,shuffle=True)

testset = CIFAR10(root="./content", train=False, download=True, transform=transform)
test_dataloader = DataLoader(dataset = testset , batch_size = batch_size , shuffle=False)

classes = ["plane", "car", "bird", "cat", "deer", "dog", "frog", "horse", "ship", "truck"]

import torch.nn as nn

class CNN_Model(nn.Module):
    def __init__(self):
        super(CNN_Model, self).__init__()

        self.conv1 = nn.Conv2d(3, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2)
        self.conv2 = nn.Conv2d(64, 128, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2)

        # Fully Connected Layers (Fixed)
        self.fc1 = nn.Linear(128 * 8 * 8, 128)  # 128 filters, feature map size = 8x8
        self.fc2 = nn.Linear(128, 10)  # Output layer (10 classes)
        self.relu = nn.ReLU()  # Fixed ReLU typo

    def forward(self, x):
        x = self.pool(self.relu(self.conv1(x)))
        x = self.pool(self.relu(self.conv2(x)))
        x = x.view(-1, 128 * 8 * 8)  # Flatten before FC layers
        x = self.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# Initialize model
model = CNN_Model()
model = model.to(device)
print(model)

# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop

for epoch in range(num_epochs):
    running_loss = 0.0
    for images, labels in train_dataloader:
        images, labels = images.to(device), labels.to(device)

        # Forward pass
        outputs = model(images)
        loss = criterion(outputs, labels)

        # Backward pass and optimization
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

        running_loss += loss.item()

    print(f"Epoch {epoch+1}/{epochs}, Loss: {running_loss/len(train_dataloader)}")

print("Training complete!")

correct = 0
total = 0

# Disable gradient computation for testing
model.eval()
with torch.no_grad():
    for images, labels in test_dataloader:
        images, labels = images.to(device), labels.to(device)
        outputs = model(images)
        _, predicted = torch.max(outputs, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

accuracy = 100 * correct / total
print(f"Test Accuracy: {accuracy:.2f}%")

torch.save(model.state_dict(),"/content/content/mycnnmodel.pth")

